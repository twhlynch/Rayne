#version 400

#include <shader/rn_Matrices.vsh>
#include <shader/rn_Shadow.vsh>

// triangles, quads, or isolines
layout (triangles, equal_spacing, ccw) in;

in vec3 tcPosition[];
in vec4 tcTexcoord[];

in vec3 tcNormal[];
in vec3 tcBitangent[];
in vec3 tcTangent[];

uniform sampler2D mTexture1;
uniform sampler2D mTexture4;

out vec3 vertPosition;
out vec4 vertTexcoord;

out vec3 vertNormal;
out vec3 vertBitangent;
out vec3 vertTangent;

void main()
{
	vertNormal = gl_TessCoord.x*tcNormal[0]+gl_TessCoord.y*tcNormal[1]+gl_TessCoord.z*tcNormal[2];
	vertBitangent = gl_TessCoord.x*tcBitangent[0]+gl_TessCoord.y*tcBitangent[1]+gl_TessCoord.z*tcBitangent[2];
	vertTangent = gl_TessCoord.x*tcTangent[0]+gl_TessCoord.y*tcTangent[1]+gl_TessCoord.z*tcTangent[2];

	vec4 t0 = gl_TessCoord.x * tcTexcoord[0];
	vec4 t1 = gl_TessCoord.y * tcTexcoord[1];
	vec4 t2 = gl_TessCoord.z * tcTexcoord[2];
	vertTexcoord = t0 + t1 + t2;

	vec3 p0 = gl_TessCoord.x * tcPosition[0];
	vec3 p1 = gl_TessCoord.y * tcPosition[1];
	vec3 p2 = gl_TessCoord.z * tcPosition[2];
	vertPosition = p0 + p1 + p2;
	vertPosition += normalize(vertNormal)*texture(mTexture4, vertTexcoord.xy).r*0.8*texture(mTexture1, vertTexcoord.zw).r;
	
#if defined(RN_LIGHTING)
	#if defined(RN_DIRECTIONAL_SHADOWS)
		rn_ShadowDirectional0(vec4(vertPosition, 1.0));
	#endif
	#if defined(RN_SPOT_SHADOWS)
		rn_ShadowSpot(vec4(vertPosition, 1.0));
	#endif
#endif

	gl_Position = matProjView * vec4(vertPosition, 1.0);
}